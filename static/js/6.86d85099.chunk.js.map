{"version":3,"sources":["routes/posts/2019-09-06-About Kafka/document.mdx","routes/posts/2019-09-06-About Kafka/document.module.css","routes/posts/2019-09-06-About Kafka/facepalm.gif","routes/posts/2019-09-06-About Kafka/order.gif"],"names":["readingTime","text","minutes","time","words","layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_home_user_Documents_projects_blog_client_react_blog_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","parentName","href","id","className","styles","src","facepalm","alt","order","isMDXComponent","tableOfContents","arguments","length","undefined","level","title","children","frontMatter","module","exports","image","figure","figureright","figureleft","sidebarcontainer","sidebar","__webpack_require__","p"],"mappings":"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","file":"static/js/6.86d85099.chunk.js","sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\nexport const readingTime = {\"text\":\"16 min read\",\"minutes\":15.34,\"time\":920400,\"words\":3068}\n/* @jsx mdx */\nimport styles from './document.module.css'\nimport facepalm from './facepalm.gif'\nimport order from './order.gif'\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <p>{`In our blog `}<a parentName=\"p\" {...{\n        \"href\": \"../../2019-08-19/Data-Engineering-Pt-1\"\n      }}>{`series`}</a>{` on data engineering and data science, we decided to use Kafka as a distributed data plane for the platform. For a fairly simple system, there is quite a lot to say about Kafka, and plenty of ways for you to embarrass yourself while implementing whatever business-value-adding-doovalacky is important this week. In this post we’ll cover some of the most common, dangerous, or strangest.`}</p>\n    <p><em parentName=\"p\">{`NB: I promise this will be the last conceptual post for a while and the next several will be pure implementation with substantially more code. While I personally think this post is a bit dry, I was explaining so many Kafka concepts in the following few that I decided to consolidate them all in a single post. I have tried to add some levity by swearing a lot, hopefully this helps.`}</em></p>\n    <h2 {...{\n      \"id\": \"kafka-basics\"\n    }}>{`Kafka Basics`}</h2>\n    <p>{`Kafka is a key-value setup, where keys and values are understood only as arbitrary bytes. There are a few concepts to understand in order to use it effectively, including brokers, topics, partitions, replications and consumer groups. Kafka itself does relatively little, it doesn’t understand any data type other than raw bytes, makes no decisions about how to assign data across a cluster, and doesn’t decide how to feed that data back to consumers. `}<strong parentName=\"p\">{`Typically, you’ll be told that keys in Kafka are for either`}</strong>{` (a) partitioning/distributing the data on the cluster; or (b) something to do with indexing, like a database table index. Both statements are bullshit, and we’ll explore why below.`}</p>\n    <figure className={styles[\"figure\"]}>\n  <img src={facepalm} className={styles[\"image\"]} alt=\"facepalm.\" />\n  <figcaption>I fucked up, so you don't have to.</figcaption>\n    </figure>\n    <p>{`One of the reasons there might be so many misconceptions about the system is that there are a variety of other tools in the ecosystem which are often referred to in the same breath as Kafka (e.g. the Kafka streams library for Scala and Java, or the confluent Avro serialisers which interface with the schema registry - another component commonly deployed with kafka). All of these tools use Kafka’s primitives (partitions, topics, consumer groups) in different ways.`}</p>\n    <p>{`The schema registry in particular deserves a quick explanation, as it stores `}<strong parentName=\"p\">{`Avro schemata which are often used to serialise messages on Kafka.`}</strong>{` The schemata are required for both serialisation and deserialisation, and the schema registry is an external system which can provide these. The Confluent avro serialiser makes use of it to automatically retrieve and write schema in Java and Scala. Similar Kafka clients exist for Python also.`}</p>\n    <div className={styles[\"sidebarcontainer\"]}>\n      <h3 {...{\n        \"id\": \"consumers-and-consumer-groups\"\n      }}>{`Consumers and consumer groups`}</h3>\n      <p>{`Consumers (of which there may be many for a given topic) subscribe to a partition (or several) within a topic to receive data as it arrives at the brokers. Once data is received, the consumer “commits” an offset to track where it is up to in the stream. In case of failure, this can be used to restart processing.`}</p>\n      <span className={styles[\"sidebar\"]}>\n        <h3 {...{\n          \"id\": \"offsets-are-committed\"\n        }}>{`Offsets are committed!`}</h3>\n        <p>{`Great, but `}<strong parentName=\"p\">{`where`}</strong>{` are they committed sorry? Another fact that is often missed about Kafka is that consumers actually make that decision. While traditionally Zookeeper was often used for this purpose, we might equally decide to use some other database, (like etcd). I believe that as of Kafka 0.9, there is a topic in Kafka which handles this, but that isn’t always optimal.`}</p>\n        <p>{`For a stateless consumer, there’s no reason to track offsets at all. For high performance consumers, or where there are a large number of consumers (e.g. Kafka is backing data delivered via a RESTful web API to a browser app) you might want to make the consumers responsible for tracking their own offsets locally.`}</p>\n        <p><strong parentName=\"p\">{`Commit behaviour is often overlooked, but can be a powerful tool.`}</strong>{` For example, a microservice might do some processing to each record and send it to an external REST API. It could be configured to commit an offset only once a 200 `}<inlineCode parentName=\"p\">{`OK`}</inlineCode>{` response had been received. In the event of failure in the external API, no offsets are commited and the data remains “unread” as far as Kafka is concerned. Even in the event of a consumer crash concurrently, we can ensure reliable delivery to the third party and data will not be lost.`}</p>\n      </span>\n      <p>{`Consumers form consumer groups, and a given consumer group receives the same data only once. Not every consumer will receive every message on a topic, but it will receive every message on its partition. `}<strong parentName=\"p\">{`You can see how this naturally leads to thinking of a service or application as a consumer group, and the consumers as instances of the application.`}</strong></p>\n      <h3 {...{\n        \"id\": \"partitions\"\n      }}>{`Partitions`}</h3>\n      <p>{`Partitions are the primary way Kafka parallelises computations. A partition is just a segment of data which has been allocated to a broker. The broker handles all consumer and producer related activity for that particular segment/shard/partition of data.`}</p>\n      <p>{`Because consumers, consumer groups, the application logic relying on the consumer, and the number of instances of the application are all tightly linked, `}<strong parentName=\"p\">{`it is highly desirable to avoid changing the number of partitions in production.`}</strong>{` All partitions are always allocated out to however many consumers you run, so it makes sense to overprovision partitions for future data growth. You can’t run more application instances than you have partitions.`}</p>\n      <p><strong parentName=\"p\">{`For that reason, I usually suggest using a minimum of 9 partitions for large clusters, or 2–3 times the number of brokers for small clusters.`}</strong>{` A cluster is rarely smaller than 3 brokers, hence the lower limit of 9. Two partitions per broker doesn’t do much harm, but it does cater for the possibility of growth in the volumes of data (and if your data volume isn’t growing, best start looking for a new job).`}</p>\n    </div>\n    <p>{`One further benefit of overprovisioning your partitions is that it helps with cluster rebalancing. Anyone who’s ever looked at discrete optimisation for any packing problem (or just taken an overseas flight on a budget airline) can attest that the most efficient optimisation is simply to make the components to be packed as small as possible. If we have 9 small partitions instead of 3 big ones, it becomes much easier to fit them onto brokers that might otherwise not have capacity for them.`}</p>\n    <p>{`Historically `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.confluent.io/blog/how-choose-number-topics-partitions-kafka-cluster\"\n      }}>{`fewer partitions were desirable for performance reasons`}</a>{`, but more recent versions of Kafka suffer `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.confluent.io/blog/apache-kafka-supports-200k-partitions-per-cluster\"\n      }}>{`few performance drawbacks`}</a>{` from increasing the number.`}</p>\n    <p>{`Finally, it bears mentioning that different Kafka designs can make use of different partitioning arrangements. One common misconception (explored below) is that partitioning always happens to same way. Actually, `}<strong parentName=\"p\">{`it is the consumers and producers which decide how partitioning occurs.`}</strong>{` Kafka can map from partitions to brokers (and therefore retrieve the data in a particular partition) but it does not keep track of which data is in which partition.`}</p>\n    <h3 {...{\n      \"id\": \"topics\"\n    }}>{`Topics`}</h3>\n    <p>{`Topics are the most visible entity in Kafka, so of course, everyone thinks they understand them. They are most usually wrong. Many of the misconceptions below are about topics, and those who repeat them are usually highly confident in their pronouncements.`}</p>\n    <figure className={styles[\"figure\"]}>\n  <img src={order} className={styles[\"image\"]} alt=\"Order!\" />\n  <figcaption>Keep it orderly.</figcaption>\n    </figure>\n    <p>{`While there are analogies to be made between topics and database tables, and while we do often see that a topic will be linked to an Avro schema (and indeed, it might be only one schema, not several) none of these facts actually captures what a topic is for. In a nutshell, topics (at least in a well designed Kafka system) actually encapsulate an ordering of their messages.`}</p>\n    <p>{`Kafka is a streaming system, so delivery of messages in-order is important. Kafka guarantees that a given consumer will receive all messages on a given partition in the order they were written. There are two catches here -`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Messages between different topics enjoy no such guarantee.`}</li>\n      <li parentName=\"ol\">{`Message between partitions receive no such guarantee.`}</li>\n    </ol>\n    <p>{`As a result, if you were in a situation where you wanted to preserve the ordering of a particular data stream within your system (for example, you’re implementing an `}<a parentName=\"p\" {...{\n        \"href\": \"https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)\"\n      }}>{`event sourcing`}</a>{` system), it needs to be mapped (through the partitioning strategy mentioned above) to a single partition. `}<strong parentName=\"p\">{`We give some examples below as to how this plays out later in this post`}</strong>{`, as messages being delivered out of order is one consequence of Kafka-fuck-ups numbers five through six, below. They are particularly interesting because `}<strong parentName=\"p\">{`solutions are not very widely available for all language APIs`}</strong>{`, and the documentation surrounding them is economical in its insights (if not outright nonsense and probably written by someone in marketing).`}</p>\n    <p><strong parentName=\"p\">{`So why do we still talk about topics providing the ordering? `}</strong>{` Because topics hold both the partitions and the partitioning strategies, so provided the partitioning strategies are rational (and people tend not to think about these very much due to them often being provided by Confluent and the like) we can assume that we get the ordering guarantees we’re looking for.`}</p>\n    <h3 {...{\n      \"id\": \"replications\"\n    }}>{`Replications?`}</h3>\n    <p>{`Replications differ from partitions, while partitions split data across the cluster to shard it out amongst the Kafka instances, replications copy the entire topic (with the same  partitioning scheme) to other brokers. This is for durability and availability - so that broker failure cannot cause data loss - but one strange implication is that sometimes brokers will have the entire dataset on them, which seems at odds with the idea of using a distributed system. For example, if we have 3 brokers, partitions and replications, every replication has to be on a different broker, which means that each broker will have a replication of each partition. While this seems to defeat the point of using a distributed system, it is actually no different to the way striped RAID used to work, and once we add more brokers (if we decide we need to) we will find each partition of each replication (9 partitions) can be placed anywhere within the cluster.`}</p>\n    <h1 {...{\n      \"id\": \"top-misconceptions-about-kafka\"\n    }}>{`Top misconceptions about Kafka`}</h1>\n    <p>{`Ah the part you were waiting for… What are some of the ways all of this can go wrong? Normally things going wrong starts with someone misunderstanding how the system works and what’s implied by that. There are plenty of ways for this to happen even in a relatively simple system like Kafka.`}</p>\n    <h3 {...{\n      \"id\": \"1-partitioning-happens-according-to-the-key-therefore\"\n    }}>{`1. Partitioning happens according to the key, therefore…`}</h3>\n    <p>{`Actually partitioning happens according to whatever partitioning strategy our producers are using. You also want to hope that the consumers know about this, or they won’t know how to process the data they receive. I had this debate with some colleagues at one stage, where we discussed whether using differently named Avro schemata for a key would land messages on different partitions (because the hash of the key would be different due to the differing magic numbers in the two schemata).`}</p>\n    <p>{`From recollection, some further research turned up the fact that the Confluent Avro Serialiser actually does some work to hash the logical (not serialised) value of the Avro message, in order to correctly allocate it to a partition irrespective of the magic number, schema name, or other considerations.`}</p>\n    <h3 {...{\n      \"id\": \"2-all-of-our-topics-just-have-three-partitions-theres-no-point-running-more-than-three-brokers\"\n    }}>{`2. All of our topics just have three partitions, there’s no point running more than three brokers…`}</h3>\n    <p>{`The mistake seems obvious when you’re looking for it, but I’ve heard this more than once. Naturally, if you have more than one topic, you can distribute partitions for different topics to brokers across the cluster. Not every broker needs to hold the same set of topics.`}</p>\n    <div className={styles[\"sidebarcontainer\"]}>\n      <h3 {...{\n        \"id\": \"3-a-topic-is-just-like-a-table\"\n      }}>{`3. A topic is just like a table`}</h3>\n      <p>{`Absolutely not. Topics support multiple data types (see above), they do not support mutable operations (there’s no update, only inserts and subsequent deletes).`}</p>\n      <p>{`Topics should be thought of as a “slice of state” (to borrow from the React.JS community’s writings on flux libraries). That slice can contain a duplicate of data held elsewhere, that’s fine. Normalisation is not important, what is important is the ordering of the events relative to one another within the topic.`}</p>\n      <span className={styles[\"sidebar\"]}>\n        <h2 {...{\n          \"id\": \"partitioning-and-in-order-delivery---an-example\"\n        }}>{`Partitioning and in order delivery - an example`}</h2>\n        <p>{`If you were streaming tweets, and had included a particular type of message indicating that a tweet was deleted, it would be important to ensure that the original tweet and the record indicating that it was deleted resided within the same partition.`}</p>\n        <p>{`Naturally, this causes a deal of complexity. Imagine a system with users, tweets and tweet deletion functionality. If each were stored in a database table, and we did change data capture (CDC) to track changes to the underlying rows, a naive approach might;`}</p>\n        <ol>\n          <li parentName=\"ol\">{`Push these into seperate Kafka topics with their own defined data structures.`}</li>\n          <li parentName=\"ol\">{`Key the events according to the database keys.`}</li>\n        </ol>\n        <p>{`Both would be wrong. There should be a single topic and a key that makes sense across all three entities (probably a user ID given it is the highest level entity). In reality, to ensure we retained consistency we would need to ensure that eventually all data related to a user was mapped to a single partition. If users were on a different partition to Tweets it would be impossible to ascertain if user data had changed before or after a tweet, but if tweets and deletions were on seperate partitions, it would be impossible for a given recipient of a tweet to determine whether a tweet had been deleted.`}</p>\n        <p>{`Event sourcing is a set of architectural patterns which can help resolve these issues. Under an ES approach, we’d ensure that any changes from the tweet and deletion tables were joined to some user key field prior to being sent to Kafka. The user is the actor entity in this situation, and only a single user can create a tweet. `}<strong parentName=\"p\">{`Multiple primary entities becomes even more complex.`}</strong>{` If we were talking about DMs between users, both need to be considered primary and ES might advocate that we replicate the data under two keys, one belonging to each user. In this case, we’d say that only a single user can create or receive a DM, and would probably create `}<inlineCode parentName=\"p\">{`SentMessage`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`ReceivedMessage`}</inlineCode>{` event types which would hold mirror images of the same data. The important thing in both cases is that there is a primary actor entity which can be referred to with a single key so that its data can be routed to the correct partition.`}</p>\n        <p><strong parentName=\"p\">{`As these examples demonstrate, it is normal to see data replicated and stored in a very denormalised format within event based systems.`}</strong></p>\n      </span>\n      <h3 {...{\n        \"id\": \"4-oh-but-when-it-is-log-compacted-then-a-topic-is-just-like-a-table-right\"\n      }}>{`4. Oh, but when it is log compacted, THEN a topic is just like a table, right?`}</h3>\n      <p>{`No, still no. Tables are still tables and topics are still topics. One is for normalising subsets of that data to avoid duplication (if you’re using an RDBMS; if you aren’t, you don’t have tables) and one is for ensuring an ordering of subsets of that data. They are not the same, there has been no prestidigitation performed, no rabbits have been pulled out of hats.`}</p>\n      <p>{`For all the reasons above, this is again incorrect. And when you update a key in the log compacted table, you are doing an `}<inlineCode parentName=\"p\">{`INSERT`}</inlineCode>{` followed by a `}<inlineCode parentName=\"p\">{`DELETE`}</inlineCode>{` some unspecific length of time later. You are not, under any circumstances, doing an `}<inlineCode parentName=\"p\">{`UPDATE`}</inlineCode>{`.`}</p>\n      <h3 {...{\n        \"id\": \"5-a-topic-should-contain-a-single-type-of-data\"\n      }}>{`5. A topic should contain a single type of data`}</h3>\n      <p>{`I’m guilty of this one, and it wasn’t until I started asking why the registry allowed `}<a parentName=\"p\" {...{\n          \"href\": \"https://www.confluent.io/blog/put-several-event-types-kafka-topic/\"\n        }}>{`multiple schemata per topic`}</a>{` that I figured it out. As you can see from the sidebar, there are situations where you’ll need to have multiple event types in a single partition - mostly when those event types relate to each other in some clearly defined way which is dependant on their ordering. You can’t have a refund before you’ve made a sale, you can’t delete an email before you’ve received it, you can’t end a call or web session before you’ve commenced it.`}</p>\n      <p>{`The events indicating that these things have happened will often have different schemata and (if you use a type heavy language like Scala) different types; as the fields required might be quite different. Those required to describe a refund will clearly differ from those required to describe a sale. But there is no way that a refund should ever occur in advance of a sale, so they really should be in the same topic (unless you really like being a victim of fraud, in which case go for gold).`}</p>\n      <p>{`This is further evidence of how a topic is not-like-a-table, so people who subscribe to the former fallacy are probably also vulnerable to the latter..`}</p>\n      <p>{`*`}<em parentName=\"p\">{`Note that if you do have to take this path, it should be a conscious decision, and you should probably turn off automatic schema creation in your Kafka Producer. Where this functionality is not required, the schema registry should be configured to only allow one schema. Failing to do so (especially if working in a team) means that any change to the schema can break compatibility for any producers which haven’t received the change. It is painful.`}</em></p>\n      <h3 {...{\n        \"id\": \"6-we-can-join-data-between-different-topics\"\n      }}>{`6. We can join data between different topics`}</h3>\n      <p>{`As we’ve established in depth above, topics are for ordering events. We often need to both;`}</p>\n      <ol>\n        <li parentName=\"ol\">{`Think carefully about partitioning strategy to ensure messages are on the same partition where their ordering matters.`}</li>\n        <li parentName=\"ol\">{`Allow several varieties of messages on a single topic, even if this means allowing several Avro schema for that topic.`}</li>\n      </ol>\n      <p>{`This is particularly unfortunate when a single topic has been split into several, and someone then decides that recombining them is then required. Kafka Streams claims to do roughly this, but the documentation glosses over all of these nuances in favor of bullshit. The reality is that this is really not possible. For example, if additional processing steps (or simple network latency) delay the messages from one stream, joins may be missed. Kafka streams can use the timestamps on the messages in various ways, but it cannot use them to reimpose proper ordering on a stream which has been split. `}<em parentName=\"p\">{`And if that exact wording could be added to the doco I think we’d see far fewer poor implementations, bluntly.`}</em></p>\n    </div>\n    <p>{`So there you go, a bunch of ways to stuff up data systems based on Kafka. If you have seen anything else terrible, hilarious, or outright scary when developing systems on Kafka, let me know on `}<a parentName=\"p\" {...{\n        \"href\": \"https://twitter.com/MilesGarnsey/\"\n      }}>{`Twitter`}</a>{` and we can swap war stories.`}</p>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\nexport const tableOfContents = (components={}) => [\n  {\n    id: \"kafka-basics\",\n    level: 2,\n    title: \"Kafka Basics\",\n    children: [\n        {\n              id: \"consumers-and-consumer-groups\",\n              level: 3,\n              title: \"Consumers and consumer groups\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"offsets-are-committed\",\n              level: 3,\n              title: \"Offsets are committed!\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"partitions\",\n              level: 3,\n              title: \"Partitions\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"topics\",\n              level: 3,\n              title: \"Topics\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"replications\",\n              level: 3,\n              title: \"Replications?\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"1-partitioning-happens-according-to-the-key-therefore\",\n              level: 3,\n              title: \"1. Partitioning happens according to the key, therefore…\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"2-all-of-our-topics-just-have-three-partitions-theres-no-point-running-more-than-three-brokers\",\n              level: 3,\n              title: \"2. All of our topics just have three partitions, there’s no point running more than three brokers…\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"3-a-topic-is-just-like-a-table\",\n              level: 3,\n              title: \"3. A topic is just like a table\",\n              children: [\n                      \n                    ]\n            }\n      ]\n  },\n{\n    id: \"partitioning-and-in-order-delivery---an-example\",\n    level: 2,\n    title: \"Partitioning and in order delivery - an example\",\n    children: [\n        {\n              id: \"4-oh-but-when-it-is-log-compacted-then-a-topic-is-just-like-a-table-right\",\n              level: 3,\n              title: \"4. Oh, but when it is log compacted, THEN a topic is just like a table, right?\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"5-a-topic-should-contain-a-single-type-of-data\",\n              level: 3,\n              title: \"5. A topic should contain a single type of data\",\n              children: [\n                      \n                    ]\n            },\n      {\n              id: \"6-we-can-join-data-between-different-topics\",\n              level: 3,\n              title: \"6. We can join data between different topics\",\n              children: [\n                      \n                    ]\n            }\n      ]\n  }\n]\n\nexport const frontMatter = {}\n\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"image\":\"document_image__2FL70\",\"figure\":\"document_figure__1_Xbb\",\"figureright\":\"document_figureright__JDuUu\",\"figureleft\":\"document_figureleft__8DdIg\",\"sidebarcontainer\":\"document_sidebarcontainer__1fEfN\",\"sidebar\":\"document_sidebar__QQejK\"};","module.exports = __webpack_public_path__ + \"static/media/facepalm.d3a73841.gif\";","module.exports = __webpack_public_path__ + \"static/media/order.e91267ca.gif\";"],"sourceRoot":""}
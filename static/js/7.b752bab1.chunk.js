(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"readingTime",function(){return p}),n.d(t,"default",function(){return h}),n.d(t,"tableOfContents",function(){return m}),n.d(t,"frontMatter",function(){return j});var a=n(16),i=(n(0),n(22)),o=n(78),r=n.n(o),c=n(79),s=n.n(c),l=n(80),b=n.n(l),p={text:"7 min read",minutes:6.73,time:403800,words:1346},d={},u="wrapper";function h(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)(u,Object.assign({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"OK, so you\u2019ve read the links from the last blog in this series and probably found them as abstruse as I did. Perhaps even as abstruse as the word abstruse. "),Object(i.b)("p",null,"By reading the tea leaves and perhaps disembowelling some small animals in the hopes of divining the truth via haruspitic practice, I succeeded in reading the portents and interpreting the signs in the docs, finally arriving at a solution. "),Object(i.b)("p",null,"This is part III of this series, and I\u2019m finally going to stop swearing (JKS), and teasing and provide it."),Object(i.b)("h1",{id:"when-your-pointer-is-an-interface"},"When your pointer is an interface"),Object(i.b)("p",null,"As we\u2019ve previously discussed, the core issue here is that our function signature reads as follows ",Object(i.b)("inlineCode",{parentName:"p"},"func ReconcileObject[U Reconcilable[U]](ctx context.Context, kClient client.Client, desiredObject U)"),", causing the call to ",Object(i.b)("inlineCode",{parentName:"p"},"new(U)")," in our function to yield a ",Object(i.b)("inlineCode",{parentName:"p"},"nil")," (which is unacceptable to ",Object(i.b)("inlineCode",{parentName:"p"},"client.Get"),"). This is because ",Object(i.b)("inlineCode",{parentName:"p"},"new()")," always instantiates the zero value - which for a pointer is always ",Object(i.b)("inlineCode",{parentName:"p"},"nil"),"."),Object(i.b)("h2",{id:"calling-with-a-value-type"},"Calling with a value type"),Object(i.b)("p",null,"As cooked as this situation clearly is, let\u2019s try and use a non-pointer type in the call to the function first, just to see what happens:"),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),'func ReconcileObject_Test(t *testing.T) {\n    desiredObject := corev1.ConfigMap{\n        ObjectMeta: metav1.ObjectMeta{\n            Name:      "test-cm",\n            Namespace: "test-namespace",\n        },\n    }\n    ctx := context.Background()\n    client := fake.NewClientBuilder().\n        Build()\n\n    err := ReconcileObject(ctx, client, &desiredObject)\n    assert.NoError(t, err)\n}\n\n')),Object(i.b)("p",null,"Catch up on the whole repo at ",Object(i.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/Miles-Garnsey/go-generics-blog/commit/22d47b068f650180f00f721809eff61462b29857"}),"this commit"),"."),Object(i.b)("div",{className:r.a.sidebarcontainer},Object(i.b)("span",null,Object(i.b)("figure",{className:r.a.figure},Object(i.b)("img",{src:s.a,className:r.a.image,alt:"Elmo starting fire.",style:{width:"30rem"}}),Object(i.b)("figcaption",null,"Its rude to point."))),Object(i.b)("span",null,Object(i.b)("p",null,"The error reads:"),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),'"k8s.io/api/core/v1".ConfigMap does not satisfy Reconcilable["k8s.io/api/core/v1".ConfigMap] (wrong type for method DeepCopy)\n        have DeepCopy() *"k8s.io/api/core/v1".ConfigMap\n        want DeepCopy() "k8s.io/api/core/v1".ConfigMapcompilerInvalidTypeArg\n')),Object(i.b)("p",null,"Which is entirely unsurprising, since we\u2019ve stated the non-pointer ",Object(i.b)("inlineCode",{parentName:"p"},"ConfigMap")," ",Object(i.b)("inlineCode",{parentName:"p"},"U")," is the thing that must fulfil our interface ",Object(i.b)("inlineCode",{parentName:"p"},"Reconcileable[U]"),", and this is defined as:"),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),"type Reconcilable[T any] interface {\n    client.Object\n    DeepCopy() T\n    DeepCopyInto(T)\n}\n")),Object(i.b)("p",null,"Whereas we know that for both ",Object(i.b)("inlineCode",{parentName:"p"},"DeepCopy() T")," and ",Object(i.b)("inlineCode",{parentName:"p"},"DeepCopyInto(T)")," the ",Object(i.b)("inlineCode",{parentName:"p"},"T")," variable must be a pointer because that\u2019s how it is defined on ",Object(i.b)("inlineCode",{parentName:"p"},"ConfigMaps")," (with a pointer receiver)."))),Object(i.b)("h2",{id:"enforcing-that-your-type-is-a-pointer-to-its-type-parameter"},"Enforcing that your type is a pointer to it\u2019s type parameter"),Object(i.b)("p",null,"I\u2019ll cut to the chase. Based on my late night browsing, the fix for this is to have a trick (",Object(i.b)("inlineCode",{parentName:"p"},"*T"),") in your interface and mention that some of the return values for the relevant methods are actually *T as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),"type Reconcilable[T any] interface {\n    client.Object\n    DeepCopy() *T\n    DeepCopyInto(*T)\n    *T\n}\n")),Object(i.b)("p",null,"This means (and I\u2019m making a guess, since I\u2019ve seen no explanation interpretable by a child of man) that "),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"T can call methods of ","*","T and;"),Object(i.b)("li",{parentName:"ol"},"That some of those methods return ","*","T, not T.")),Object(i.b)("p",null,"When we then write our reconciliation function, we can then do this, passing two LINKED type parameters:"),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),"func ReconcileObject[T any, U Reconcilable[T]](ctx context.Context, kClient client.Client, desiredObject T) error {\n    desiredObjectName := types.NamespacedName{\n        Name:      desiredObject.GetName(),\n        Namespace: desiredObject.GetNamespace(),\n    }\n    currentObject := new(T)\n    err := kClient.Get(ctx, desiredObjectName, currentObject)\n    if err != nil {\n        return err\n    }\n    desiredObject.DeepCopyInto(currentObject)\n    return nil\n}\n")),Object(i.b)("p",null,"See the whole repo at ",Object(i.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/Miles-Garnsey/go-generics-blog/commit/3d5a153d81e0ed7c550b87db984708c8b7c5629e"}),"this commit"),"."),Object(i.b)("p",null,"The fact that we are passing type parameter ",Object(i.b)("inlineCode",{parentName:"p"},"T")," into ",Object(i.b)("inlineCode",{parentName:"p"},"U")," is critical, since we are asserting type constraints that ",Object(i.b)("inlineCode",{parentName:"p"},"T")," is ",Object(i.b)("inlineCode",{parentName:"p"},"any"),", but that it\u2019s ",Object(i.b)("strong",{parentName:"p"},"pointer")," must implement certain methods and interfaces. "),Object(i.b)("p",null,"A pleasing consequence: Go is smart enough (for once) to understand the constraints and make type inferences out of the ",Object(i.b)("inlineCode",{parentName:"p"},"desiredObject"),", so our callers never need to know they\u2019ve told us their types. "),Object(i.b)("p",null,"Moreover, our call to ",Object(i.b)("inlineCode",{parentName:"p"},"new(T)")," now yields a real value of ",Object(i.b)("inlineCode",{parentName:"p"},"ConfigMap{}")," (and take significant note of the ",Object(i.b)("inlineCode",{parentName:"p"},"{}")," appended, because they are also critical)."),Object(i.b)("p",null,"Oh but we still have plenty of errors:"),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),"desiredObject.GetName undefined (type T has no field or method GetName)\ndesiredObject.GetNamespace undefined (type T has no field or method GetNamespace)\ndesiredObject.DeepCopyInto undefined (type T has no field or method DeepCopyInto)\n")),Object(i.b)("p",null,"So we might think to try adding a variety of ",Object(i.b)("inlineCode",{parentName:"p"},"&")," and ",Object(i.b)("inlineCode",{parentName:"p"},"*")," operators to our variables to pointerise and dereference our way out of this mess. Perhaps something like;"),Object(i.b)("div",{className:r.a.sidebarcontainer},Object(i.b)("span",null,Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),"func ReconcileObject[T any, U Reconcilable[T]](ctx context.Context, kClient client.Client, desiredObject T) error {\n    desiredObjectName := types.NamespacedName{\n        Name:      (&desiredObject).GetName(),\n        Namespace: (&desiredObject).GetNamespace(),\n    }\n    currentObject := new(T)\n    err := kClient.Get(ctx, desiredObjectName, &currentObject)\n    if err != nil {\n        return err\n    }\n    (&desiredObject).DeepCopyInto(currentObject)\n    return nil\n}\n")),Object(i.b)("p",null,"See ",Object(i.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/Miles-Garnsey/go-generics-blog/commit/b86287c8a12c142473fdde0bf4040f43af8b49b9"}),"this commit"),"."),Object(i.b)("p",null,"This would also crash and burn in truly spectacular fashion, do you know why? I don\u2019t. All I know is that converting between pointer and value types doesn\u2019t work like this when you\u2019re dealing with generics. ")),Object(i.b)("span",null,Object(i.b)("figure",{className:r.a.figure},Object(i.b)("img",{src:b.a,className:r.a.image,alt:"a trainwreck.",style:{width:"40rem"}}),Object(i.b)("figcaption",null,"Actual footage of this attempt to massage types.")))),Object(i.b)("h2",{id:"explicitly-casting-between-pointer-and-value-types"},"Explicitly casting between pointer and value types"),Object(i.b)("p",null,"What you have to do is explicitly cast between your ",Object(i.b)("strong",{parentName:"p"},"type parameters"),". "),Object(i.b)("p",null,"To be clear, this logic is replete with memory allocations and performance implications - which I don\u2019t care about; because logical correctness and being able to encapsulate logic is more important to me than my cloud bill, and I charge more than an extra two CPUs per hour. "),Object(i.b)("p",null,"But be aware that in frequently called code this situation is suboptimal. Perhaps in frequently called code, consider using a programming language which is not a LOC generation toy."),Object(i.b)("p",null,"Instead of a rational situation where we ",Object(i.b)("inlineCode",{parentName:"p"},"*")," and ",Object(i.b)("inlineCode",{parentName:"p"},"&")," our little bytes into the right form, We need to do this instead:"),Object(i.b)("pre",null,Object(i.b)("code",Object.assign({parentName:"pre"},{}),"func ReconcileObject[T any, U Reconcilable[T]](ctx context.Context, kClient client.Client, desiredObject T) error {\n    desiredObjectName := types.NamespacedName{\n        Name:      U(&desiredObject).GetName(),\n        Namespace: U(&desiredObject).GetNamespace(),\n    }\n    currentObject := new(T)\n    err := kClient.Get(ctx, desiredObjectName, U(currentObject))\n    if err != nil && !errors.IsNotFound(err) {\n        return err\n    }\n    U(&desiredObject).DeepCopyInto(currentObject)\n    return nil\n}\n")),Object(i.b)("p",null,"See ",Object(i.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/Miles-Garnsey/go-generics-blog/commit/d7f0fb0ddaff71bc05d995965a461d0cc7efd432"}),"here")," for the final result."),Object(i.b)("div",{className:r.a.sidebarcontainer},Object(i.b)("span",null,Object(i.b)("h1",{id:"wrapping-up"},"Wrapping up"),Object(i.b)("p",null,"I had some choice words about how difficult this was, but I think since you\u2019ve all been on the journey you can imagine the look of slack jawed disbelief on my face when I finally got it working. I have reservations about the performance of this solution since my understanding is that each cast of the variable may take a copy. But I haven\u2019t busted out a disassembler to confirm my suspicions."),Object(i.b)("p",null,"Ultimately, what the solution comes down to is as simple as this:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"The new keyword always allocates an empty value, and because the empty value of a pointer is always a pointer, we need some way to indicate that we want an empty value of the value type."),Object(i.b)("li",{parentName:"ol"},"We simultaneously need to make assertions about the methods available on the pointer of that value type (since this is where all our copy methods reside)."),Object(i.b)("li",{parentName:"ol"},"We can access both the value and pointer types of a given type by (a) passing both value and pointer as type parameters, while (b) simultaneously asserting that we are allowed obtain a pointer to the type in the interface."))),Object(i.b)("span",{className:r.a.sidebar,styles:{marginRight:"1rem"}},Object(i.b)("h1",{id:"one-final-warning"},"One final warning"),Object(i.b)("p",null,"There is one final thing to note about this solution, which is that it can hurt you in the case that you intend to write a function to mutate ",Object(i.b)("inlineCode",{parentName:"p"},"desiredObject"),". I believe that may be the language designer\u2019s justification for point (3a) above."),Object(i.b)("p",null,"While you can use type casting between pointer and value type parameters (and use type assertions to declare that a pointer to a type satisfies certain conditions), you need to recall that no matter what contortions you perform, you won\u2019t have access to the original variable because it was passed by value. "),Object(i.b)("p",null,"Because it was passed as a value type, a copy is taken before ",Object(i.b)("inlineCode",{parentName:"p"},"ReconcileObject")," ever gets to see it, and consequently ",Object(i.b)("inlineCode",{parentName:"p"},"ReconcileObject")," can\u2019t mutate the original variable. But we don\u2019t want to do that here anyway, and I\u2019m sure you can imagine some convoluted mechanism via which you can wrap your pointer types in a struct so that a copy of the pointer is passed which retains access to the orginal memory location."),Object(i.b)("p",null,"Or you could just use Java and forget about all this pointer nonsense, functions should be pure anyway."))))}h.isMDXComponent=!0;var m=function(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return[{id:"calling-with-a-value-type",level:2,title:"Calling with a value type",children:[]},{id:"enforcing-that-your-type-is-a-pointer-to-its-type-parameter",level:2,title:"Enforcing that your type is a pointer to it\u2019s type parameter",children:[]},{id:"explicitly-casting-between-pointer-and-value-types",level:2,title:"Explicitly casting between pointer and value types",children:[]}]},j={}},78:function(e,t,n){e.exports={image:"document_image__3yQbj",figure:"document_figure__1javc",sidebarcontainer:"document_sidebarcontainer__1goNB",floatright:"document_floatright__VmDXX",sidebar:"document_sidebar__2tkcP",rainbow:"document_rainbow__3gbGp","rainbow-bg":"document_rainbow-bg__3WADk"}},79:function(e,t,n){e.exports=n.p+"static/media/leonardo.d9a9171e.gif"},80:function(e,t,n){e.exports=n.p+"static/media/trainwreck.02372606.gif"}}]);
//# sourceMappingURL=7.b752bab1.chunk.js.map